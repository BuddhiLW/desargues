(ns varcalc.videos.scenes.brachistochrone
  "Brachistochrone problem: Full derivation and animation.

   The brachistochrone (Greek: βράχιστος χρόνος = 'shortest time') is the curve
   of fastest descent under gravity between two points.

   This module provides a complete step-by-step derivation:
   1. Problem setup: minimize T = ∫dt
   2. Time element: dt = ds/v
   3. Energy conservation: v = √(2gy)
   4. Arc length: ds = √(1 + y'²)dx
   5. Functional: T = ∫ √[(1+y'²)/(2gy)] dx
   6. Beltrami identity: L - y'∂L/∂y' = C (since ∂L/∂x = 0)
   7. Solution: y(1+y'²) = 1/C² (constant)
   8. Parametric cycloid: x = A(φ - sinφ), y = A(1 - cosφ)

   Uses Emmy for symbolic computation and pure Clojure rendering via libpython-clj."
  (:require [libpython-clj2.python :as py]
            [varcalc.manim.core :as manim]
            [emmy.env :as e :refer [D simplify sin cos square sqrt ->TeX]]))

;; =============================================================================
;; Physics: Curve Definitions
;; =============================================================================

(defn straight-line
  "Straight line path from (x0, y0) to (x1, y1)."
  [x0 y0 x1 y1]
  (fn [t]
    [(+ x0 (* t (- x1 x0)))
     (+ y0 (* t (- y1 y0)))]))

(defn parabolic-path
  "Parabolic path with extra dip in the middle."
  [x0 y0 x1 y1 depth]
  (fn [t]
    [(+ x0 (* t (- x1 x0)))
     (+ y0
        (* t (- y1 y0))
        (* (- depth) (* t (- 1 t)) (Math/abs (- y1 y0))))]))

(defn cycloid-path
  "Cycloid path: the brachistochrone solution.
   x = r(θ - sin θ), y = -r(1 - cos θ)"
  [x0 y0 x1 y1]
  (let [theta-max 2.5
        r (/ (- x1 x0) (- theta-max (Math/sin theta-max)))]
    (fn [theta]
      (let [x-raw (+ x0 (* r (- theta (Math/sin theta))))
            y-raw (- y0 (* r (- 1 (Math/cos theta))))
            y-end (- y0 (* r (- 1 (Math/cos theta-max))))
            y-scale (/ (- y1 y0) (- y-end y0))
            y (+ y0 (* (- y-raw y0) y-scale))]
        [x-raw y]))))

;; =============================================================================
;; Physics Calculations
;; =============================================================================

(defn descent-time
  "Calculate descent time along a curve using energy conservation."
  [curve-fn t-start t-end n-points g]
  (let [dt (/ (- t-end t-start) n-points)
        points (mapv #(curve-fn (+ t-start (* % dt))) (range (inc n-points)))]
    (reduce +
            (map (fn [[x1 y1] [x2 y2]]
                   (let [dx (- x2 x1)
                         dy (- y2 y1)
                         ds (Math/sqrt (+ (* dx dx) (* dy dy)))
                         y-avg (/ (+ y1 y2) 2.0)
                         v (Math/sqrt (* 2 g (Math/abs y-avg)))]
                     (if (pos? v) (/ ds v) 0.0)))
                 points
                 (rest points)))))

(defn action-integral
  "Compute action S = ∫ L dt for a path."
  [curve-fn t-start t-end n-points m g]
  (let [dt (/ (- t-end t-start) n-points)
        points (mapv #(curve-fn (+ t-start (* % dt))) (range (inc n-points)))]
    (reduce +
            (map (fn [[x1 y1] [x2 y2]]
                   (let [dx (- x2 x1)
                         dy (- y2 y1)
                         vx (/ dx dt)
                         vy (/ dy dt)
                         v-sq (+ (* vx vx) (* vy vy))
                         y-avg (/ (+ y1 y2) 2.0)
                         T (* 0.5 m v-sq)
                         V (* m g y-avg)
                         L (- T V)]
                     (* L dt)))
                 points
                 (rest points)))))

(defn compare-paths [x0 y0 x1 y1]
  (let [g 9.8, m 1.0, n-points 100
        straight (straight-line x0 y0 x1 y1)
        parabola (parabolic-path x0 y0 x1 y1 2.0)
        cycloid (cycloid-path x0 y0 x1 y1)]
    {:straight {:time (descent-time straight 0.0 1.0 n-points g)
                :action (action-integral straight 0.0 1.0 n-points m g)}
     :parabola {:time (descent-time parabola 0.0 1.0 n-points g)
                :action (action-integral parabola 0.0 1.0 n-points m g)}
     :cycloid {:time (descent-time cycloid 0.0 2.5 n-points g)
               :action (action-integral cycloid 0.0 2.5 n-points m g)}}))

;; =============================================================================
;; Color Scheme
;; =============================================================================

(def colors
  {:straight :blue
   :parabola :yellow
   :cycloid :green
   :point-a :green
   :point-b :red
   :highlight :teal
   :equation :white
   :step :yellow})

(def t2c
  "Text-to-color mapping for physics equations."
  {"T" :teal "t" :teal
   "v" :orange "V" :blue
   "y" :green "y'" :green
   "x" :red
   "g" :yellow
   "L" :purple
   "C" :grey
   "A" :pink
   "\\phi" :cyan "φ" :cyan})

;; =============================================================================
;; Pure Clojure Manim Helpers
;; =============================================================================

(defn ->np-array
  "Convert Clojure vector to numpy array."
  [[x y z]]
  (let [np (py/import-module "numpy")]
    (py/call-attr np "array" [x y z])))

(defn get-color
  "Get Manim color constant from keyword."
  [color-kw]
  (let [m (manim/manim)
        color-name (case color-kw
                     :blue "BLUE"
                     :red "RED"
                     :green "GREEN"
                     :yellow "YELLOW"
                     :orange "ORANGE"
                     :purple "PURPLE"
                     :pink "PINK"
                     :teal "TEAL"
                     :cyan "BLUE_C"
                     :white "WHITE"
                     :grey "GREY"
                     :gray "GREY"
                     "WHITE")]
    (py/get-attr m color-name)))

(defn create-text
  "Create Manim Text object."
  [text & {:keys [font-size color]
           :or {font-size 36}}]
  (let [m (manim/manim)
        Text (py/get-attr m "Text")
        obj (py/call-attr-kw Text "__call__" [text]
                             {"font_size" font-size})]
    (when color
      (py/call-attr obj "set_color" (get-color color)))
    obj))

(defn create-tex
  "Create Manim MathTex object."
  [latex & {:keys [font-size color]}]
  (let [m (manim/manim)
        MathTex (py/get-attr m "MathTex")
        obj (if font-size
              (py/call-attr-kw MathTex "__call__" [latex]
                               {"font_size" font-size})
              (MathTex latex))]
    (when color
      (py/call-attr obj "set_color" (get-color color)))
    obj))

(defn create-dot
  "Create Manim Dot."
  [point & {:keys [color radius]
            :or {radius 0.08}}]
  (let [m (manim/manim)
        Dot (py/get-attr m "Dot")]
    (py/call-attr-kw Dot "__call__" []
                     {"point" (->np-array point)
                      "radius" radius
                      "color" (when color (get-color color))})))

(defn create-line
  "Create Manim Line."
  [start end & {:keys [color stroke-width]
                :or {stroke-width 3}}]
  (let [m (manim/manim)
        Line (py/get-attr m "Line")]
    (py/call-attr-kw Line "__call__" []
                     {"start" (->np-array start)
                      "end" (->np-array end)
                      "stroke_width" stroke-width
                      "color" (when color (get-color color))})))

(defn create-arrow
  "Create Manim Arrow."
  [start end & {:keys [color stroke-width]
                :or {stroke-width 4}}]
  (let [m (manim/manim)
        Arrow (py/get-attr m "Arrow")]
    (py/call-attr-kw Arrow "__call__" []
                     {"start" (->np-array start)
                      "end" (->np-array end)
                      "stroke_width" stroke-width
                      "color" (when color (get-color color))})))

(defn create-parametric-curve
  "Create Manim ParametricFunction."
  [func t-range & {:keys [color stroke-width]
                   :or {stroke-width 3}}]
  (let [m (manim/manim)
        ParametricFunction (py/get-attr m "ParametricFunction")
        wrapped-fn (fn [t]
                     (let [[x y] (func t)]
                       (->np-array [x y 0])))]
    (py/call-attr-kw ParametricFunction "__call__" [wrapped-fn]
                     {"t_range" (py/->py-list t-range)
                      "stroke_width" stroke-width
                      "color" (when color (get-color color))})))

(defn create-rectangle
  "Create Manim SurroundingRectangle."
  [mobject & {:keys [color buff stroke-width]
              :or {buff 0.2 stroke-width 2}}]
  (let [m (manim/manim)
        SurroundingRectangle (py/get-attr m "SurroundingRectangle")]
    (py/call-attr-kw SurroundingRectangle "__call__" [mobject]
                     {"buff" buff
                      "stroke_width" stroke-width
                      "color" (when color (get-color color))})))

(defn create-vgroup
  "Create Manim VGroup."
  [& mobjects]
  (let [m (manim/manim)
        VGroup (py/get-attr m "VGroup")
        group (VGroup)]
    (doseq [mob mobjects]
      (py/call-attr group "add" mob))
    group))

(defn move-to
  "Move mobject to position."
  [mobject pos]
  (py/call-attr mobject "move_to" (->np-array pos))
  mobject)

(defn shift
  "Shift mobject by offset."
  [mobject offset]
  (py/call-attr mobject "shift" (->np-array offset))
  mobject)

(defn next-to
  "Position mobject next to another."
  [mobject target direction & {:keys [buff] :or {buff 0.25}}]
  (let [m (manim/manim)
        dir-vec (case direction
                  :up (py/get-attr m "UP")
                  :down (py/get-attr m "DOWN")
                  :left (py/get-attr m "LEFT")
                  :right (py/get-attr m "RIGHT")
                  (py/get-attr m "DOWN"))]
    (py/call-attr-kw mobject "next_to" [target dir-vec] {"buff" buff})
    mobject))

(defn to-edge
  "Move mobject to screen edge."
  [mobject edge & {:keys [buff] :or {buff 0.5}}]
  (let [m (manim/manim)
        edge-vec (case edge
                   :up (py/get-attr m "UP")
                   :down (py/get-attr m "DOWN")
                   :left (py/get-attr m "LEFT")
                   :right (py/get-attr m "RIGHT")
                   (py/get-attr m "UP"))]
    (py/call-attr-kw mobject "to_edge" [edge-vec] {"buff" buff})
    mobject))

(defn to-corner
  "Move mobject to screen corner."
  [mobject corner & {:keys [buff] :or {buff 0.5}}]
  (let [m (manim/manim)
        corner-vec (case corner
                     :ul (py/call-attr (py/get-attr m "UP") "__add__" (py/get-attr m "LEFT"))
                     :ur (py/call-attr (py/get-attr m "UP") "__add__" (py/get-attr m "RIGHT"))
                     :dl (py/call-attr (py/get-attr m "DOWN") "__add__" (py/get-attr m "LEFT"))
                     :dr (py/call-attr (py/get-attr m "DOWN") "__add__" (py/get-attr m "RIGHT"))
                     (py/get-attr m "UP"))]
    (py/call-attr-kw mobject "to_corner" [corner-vec] {"buff" buff})
    mobject))

(defn arrange
  "Arrange mobjects in VGroup."
  [vgroup direction & {:keys [buff] :or {buff 0.3}}]
  (let [m (manim/manim)
        dir-vec (case direction
                  :down (py/get-attr m "DOWN")
                  :up (py/get-attr m "UP")
                  :right (py/get-attr m "RIGHT")
                  :left (py/get-attr m "LEFT")
                  (py/get-attr m "DOWN"))]
    (py/call-attr-kw vgroup "arrange" [dir-vec] {"buff" buff})
    vgroup))

;; Animation helpers
(defn anim-write [mobject]
  (let [m (manim/manim)
        Write (py/get-attr m "Write")]
    (Write mobject)))

(defn anim-create [mobject]
  (let [m (manim/manim)
        Create (py/get-attr m "Create")]
    (Create mobject)))

(defn anim-fade-in [mobject]
  (let [m (manim/manim)
        FadeIn (py/get-attr m "FadeIn")]
    (FadeIn mobject)))

(defn anim-fade-out [mobject]
  (let [m (manim/manim)
        FadeOut (py/get-attr m "FadeOut")]
    (FadeOut mobject)))

(defn anim-transform [from to]
  (let [m (manim/manim)
        Transform (py/get-attr m "Transform")]
    (Transform from to)))

(defn anim-replacement-transform [from to]
  (let [m (manim/manim)
        ReplacementTransform (py/get-attr m "ReplacementTransform")]
    (ReplacementTransform from to)))

(defn anim-grow-arrow [arrow]
  (let [m (manim/manim)
        GrowArrow (py/get-attr m "GrowArrow")]
    (GrowArrow arrow)))

(defn play! [scene & anims]
  (apply py/call-attr scene "play" anims))

(defn wait! [scene duration]
  (py/call-attr scene "wait" duration))

;; =============================================================================
;; LaTeX Equations for Full Derivation
;; =============================================================================

;; Step 1: Problem Statement
(def eq-problem "\\text{Minimize } T = \\int_{A}^{B} dt")

;; Step 2: Time element
(def eq-dt "dt = \\frac{ds}{v}")
(def eq-dt-explanation "\\text{(time = distance / velocity)}")

;; Step 3: Energy Conservation
(def eq-energy-start "\\frac{1}{2}mv^2 = mgy")
(def eq-energy-cancel "\\frac{1}{2}v^2 = gy")
(def eq-energy-solve "v^2 = 2gy")
(def eq-velocity "v = \\sqrt{2gy}")

;; Step 4: Arc Length
(def eq-arc-diff "ds^2 = dx^2 + dy^2")
(def eq-arc-factor "ds^2 = dx^2\\left(1 + \\frac{dy^2}{dx^2}\\right)")
(def eq-arc-final "ds = \\sqrt{1 + y'^2} \\, dx")
(def eq-yprime-def "\\text{where } y' = \\frac{dy}{dx}")

;; Step 5: Combine into Functional
(def eq-dt-substituted "dt = \\frac{\\sqrt{1 + y'^2} \\, dx}{\\sqrt{2gy}}")
(def eq-functional "T = \\int_{x_0}^{x_1} \\sqrt{\\frac{1 + y'^2}{2gy}} \\, dx")
(def eq-functional-clean "T = \\int_{x_0}^{x_1} \\frac{\\sqrt{1 + y'^2}}{\\sqrt{2gy}} \\, dx")

;; Step 6: Identify Lagrangian
(def eq-lagrangian-form "T = \\int L(y, y') \\, dx")
(def eq-lagrangian-def "L(y, y') = \\frac{\\sqrt{1 + y'^2}}{\\sqrt{2gy}}")
(def eq-lagrangian-simple "L = \\sqrt{\\frac{1 + y'^2}{y}} \\cdot \\frac{1}{\\sqrt{2g}}")

;; Step 7: Euler-Lagrange Equation
(def eq-euler-lagrange "\\frac{\\partial L}{\\partial y} - \\frac{d}{dx}\\frac{\\partial L}{\\partial y'} = 0")

;; Step 8: Beltrami Identity (key insight!)
(def eq-beltrami-condition "\\frac{\\partial L}{\\partial x} = 0")
(def eq-beltrami-note "\\text{Since } L = L(y, y') \\text{ has no explicit } x \\text{ dependence}")
(def eq-beltrami-identity "L - y' \\frac{\\partial L}{\\partial y'} = C")
(def eq-beltrami-name "\\text{(Beltrami Identity)}")

;; Step 9: Compute ∂L/∂y'
(def eq-partial-L "\\frac{\\partial L}{\\partial y'} = \\frac{\\partial}{\\partial y'} \\sqrt{\\frac{1+y'^2}{y}}")
(def eq-partial-L-result "\\frac{\\partial L}{\\partial y'} = \\frac{y'}{\\sqrt{y(1+y'^2)}}")

;; Step 10: Substitute into Beltrami
(def eq-beltrami-sub "\\sqrt{\\frac{1+y'^2}{y}} - y' \\cdot \\frac{y'}{\\sqrt{y(1+y'^2)}} = C")
(def eq-beltrami-simplify1 "\\frac{1+y'^2}{\\sqrt{y(1+y'^2)}} - \\frac{y'^2}{\\sqrt{y(1+y'^2)}} = C")
(def eq-beltrami-simplify2 "\\frac{1+y'^2 - y'^2}{\\sqrt{y(1+y'^2)}} = C")
(def eq-beltrami-simplify3 "\\frac{1}{\\sqrt{y(1+y'^2)}} = C")

;; Step 11: Solve for key relation
(def eq-solution-step1 "\\sqrt{y(1+y'^2)} = \\frac{1}{C}")
(def eq-solution-step2 "y(1+y'^2) = \\frac{1}{C^2}")
(def eq-solution-final "y(1+y'^2) = 2A")
(def eq-constant-def "\\text{where } 2A = \\frac{1}{C^2}")

;; Step 12: Solve the ODE
(def eq-ode-isolate "y'^2 = \\frac{2A - y}{y}")
(def eq-ode-sqrt "y' = \\frac{dy}{dx} = \\sqrt{\\frac{2A - y}{y}}")
(def eq-ode-separate "\\sqrt{\\frac{y}{2A-y}} \\, dy = dx")

;; Step 13: Substitution y = A(1 - cos φ)
(def eq-sub-y "\\text{Let } y = A(1 - \\cos\\phi)")
(def eq-sub-dy "dy = A\\sin\\phi \\, d\\phi")
(def eq-sub-2A-y "2A - y = 2A - A(1-\\cos\\phi) = A(1 + \\cos\\phi)")

;; Step 14: Evaluate the integral
(def eq-integral-sub "\\sqrt{\\frac{A(1-\\cos\\phi)}{A(1+\\cos\\phi)}} \\cdot A\\sin\\phi \\, d\\phi = dx")
(def eq-trig-identity "\\text{Using } \\frac{1-\\cos\\phi}{1+\\cos\\phi} = \\tan^2\\frac{\\phi}{2}")
(def eq-integral-simplify "A\\sin\\phi \\cdot \\tan\\frac{\\phi}{2} \\, d\\phi = dx")
(def eq-sin-identity "\\text{Using } \\sin\\phi = 2\\sin\\frac{\\phi}{2}\\cos\\frac{\\phi}{2}")
(def eq-integral-final "A(1 - \\cos\\phi) \\, d\\phi = dx")

;; Step 15: Integrate
(def eq-integrate-x "x = A(\\phi - \\sin\\phi) + x_0")

;; Step 16: Final Parametric Equations (The Cycloid!)
(def eq-cycloid-x "x = A(\\phi - \\sin\\phi)")
(def eq-cycloid-y "y = A(1 - \\cos\\phi)")
(def eq-cycloid-name "\\textbf{The Cycloid!}")

;; =============================================================================
;; Rendering Functions
;; =============================================================================

(defn render-full-derivation
  "Render the complete brachistochrone derivation video in pure Clojure."
  []
  (manim/init!)
  (println "\n=== Brachistochrone Full Derivation ===")
  (println "Rendering complete video with all 12 derivation steps..."

           subtitle (-> (typo/tex "\\beta\\rho\\alpha\\chi\\iota\\sigma\\tau o\\varsigma \\, \\chi\\rho o\\nu o\\varsigma = \\text{shortest time}"
                                  :font-size 32)
                        (mo/next-to title :down))

        ;; Points and curves
           start-point [-4 2 0]
           end-point [4 -2 0]
           pt-a (mo/dot start-point :color (:point-a colors) :radius 0.12)
           pt-b (mo/dot end-point :color (:point-b colors) :radius 0.12)
           label-a (-> (typo/tex "A" :color (:point-a colors)) (mo/next-to pt-a :up))
           label-b (-> (typo/tex "B" :color (:point-b colors)) (mo/next-to pt-b :down))

           question (-> (mo/text "Which curve minimizes the descent time under gravity?"
                                 :font-size 28)
                        (mo/shift [0 -2.5 0]))

        ;; Create curves
           straight-fn (straight-line -4 2 4 -2)
           parabola-fn (parabolic-path -4 2 4 -2 2.0)
           cycloid-fn (cycloid-path -4 2 4 -2)

           curve-straight (mo/parametric-curve
                           (fn [t] (let [[x y] (straight-fn t)] [x y 0]))
                           [0 1] :color (:straight colors) :stroke-width 3)
           curve-parabola (mo/parametric-curve
                           (fn [t] (let [[x y] (parabola-fn t)] [x y 0]))
                           [0 1] :color (:parabola colors) :stroke-width 3)
           curve-cycloid (mo/parametric-curve
                          (fn [t] (let [[x y] (cycloid-fn t)] [x y 0]))
                          [0 2.5] :color (:cycloid colors) :stroke-width 3)

        ;; Gravity arrow
           g-arrow (mo/arrow [-5.5 1 0] [-5.5 -0.5 0] :color :yellow :stroke-width 3)
           g-label (-> (typo/tex "g" :color :yellow :font-size 36)
                       (mo/next-to g-arrow :left))

           timeline
           (tl/timeline
            [:t 0 (tl/write title)]
            [:t 1 (tl/fade-in subtitle)]
            [:t 3 (tl/fade-out subtitle)]

         ;; Show points
            [:t 4 (tl/|| (tl/create pt-a) (tl/create pt-b))]
            [:t 4.5 (tl/|| (tl/write label-a) (tl/write label-b))]

         ;; Show gravity
            [:t 5.5 (tl/|| (tl/grow-arrow g-arrow) (tl/write g-label))]

         ;; Draw curves
            [:t 6.5 (tl/create curve-straight :run-time 1)]
            [:t 7.5 (tl/create curve-parabola :run-time 1)]
            [:t 8.5 (tl/create curve-cycloid :run-time 1)]

         ;; Question
            [:t 10 (tl/write question)]
            [:t 12 (tl/wait 1)])

           {:title title
            :points {:pt-a pt-a :pt-b pt-b :label-a label-a :label-b label-b}
            :curves {:straight curve-straight :parabola curve-parabola :cycloid curve-cycloid}
            :timeline timeline}))

;; =============================================================================
;; Scene: Step-by-Step Derivation
;; =============================================================================

(defn derivation-step-1-scene []
  "Step 1: Set up the minimization problem T = ∫dt"
  (let [title (-> (mo/text "Step 1: The Minimization Problem" :font-size 36 :color (:step colors))
                  (mo/to-edge :up))

        eq1 (-> (typo/tex eq-problem :t2c t2c :font-size 42)
                (mo/shift [0 1 0]))

        explanation (-> (mo/text "We want to find the curve y(x) that minimizes total travel time"
                                 :font-size 26)
                        (mo/shift [0 -0.5 0]))

        timeline
        (tl/timeline
         [:t 0 (tl/write title)]
         [:t 1 (tl/write eq1)]
         [:t 3 (tl/fade-in explanation)]
         [:t 5 (tl/wait 1)])]

    {:title title :eq1 eq1 :timeline timeline}))

(defn derivation-step-2-scene []
  "Step 2: Express dt in terms of ds and v"
  (let [title (-> (mo/text "Step 2: Time Element" :font-size 36 :color (:step colors))
                  (mo/to-edge :up))

        eq1 (-> (typo/tex eq-dt :t2c t2c :font-size 42)
                (mo/shift [0 1 0]))

        eq2 (-> (typo/tex eq-dt-explanation :font-size 28)
                (mo/next-to eq1 :down :buff 0.5))

        ;; Visual: small curve segment
        diagram-label (-> (mo/text "infinitesimal arc element:" :font-size 24)
                          (mo/shift [-3 -1 0]))

        timeline
        (tl/timeline
         [:t 0 (tl/write title)]
         [:t 1 (tl/write eq1)]
         [:t 2.5 (tl/fade-in eq2)]
         [:t 4 (tl/fade-in diagram-label)]
         [:t 5.5 (tl/wait 1)])]

    {:title title :eq1 eq1 :timeline timeline}))

(defn derivation-step-3-scene []
  "Step 3: Energy conservation gives v = √(2gy)"
  (let [title (-> (mo/text "Step 3: Energy Conservation" :font-size 36 :color (:step colors))
                  (mo/to-edge :up))

        note (-> (mo/text "Particle starts from rest at y=0, falls to height y" :font-size 24)
                 (mo/shift [0 2 0]))

        eq1 (-> (typo/tex eq-energy-start :t2c t2c :font-size 36)
                (mo/shift [0 1 0]))

        eq2 (-> (typo/tex eq-energy-cancel :t2c t2c :font-size 36)
                (mo/shift [0 0.2 0]))

        eq3 (-> (typo/tex eq-energy-solve :t2c t2c :font-size 36)
                (mo/shift [0 -0.6 0]))

        eq4 (-> (typo/tex eq-velocity :t2c t2c :font-size 48)
                (mo/shift [0 -1.8 0]))

        box (mo/surrounding-rectangle eq4 :color (:highlight colors) :buff 0.2)

        timeline
        (tl/timeline
         [:t 0 (tl/write title)]
         [:t 0.5 (tl/fade-in note)]
         [:t 1.5 (tl/write eq1)]
         [:t 3 (tl/transform-matching-tex eq1 eq2)]
         [:t 4.5 (tl/transform-matching-tex eq2 eq3)]
         [:t 6 (tl/transform-matching-tex eq3 eq4)]
         [:t 7.5 (tl/create box)]
         [:t 9 (tl/wait 1)])]

    {:title title :eq-final eq4 :box box :timeline timeline}))

(defn derivation-step-4-scene []
  "Step 4: Arc length ds = √(1+y'²)dx"
  (let [title (-> (mo/text "Step 4: Arc Length Element" :font-size 36 :color (:step colors))
                  (mo/to-edge :up))

        eq1 (-> (typo/tex eq-arc-diff :t2c t2c :font-size 36)
                (mo/shift [0 1.2 0]))

        eq2 (-> (typo/tex eq-arc-factor :t2c t2c :font-size 36)
                (mo/shift [0 0.3 0]))

        eq3 (-> (typo/tex eq-arc-final :t2c t2c :font-size 48)
                (mo/shift [0 -0.8 0]))

        eq4 (-> (typo/tex eq-yprime-def :font-size 28)
                (mo/shift [0 -1.8 0]))

        box (mo/surrounding-rectangle eq3 :color (:highlight colors) :buff 0.2)

        timeline
        (tl/timeline
         [:t 0 (tl/write title)]
         [:t 1 (tl/write eq1)]
         [:t 2.5 (tl/transform-matching-tex eq1 eq2)]
         [:t 4 (tl/transform-matching-tex eq2 eq3)]
         [:t 5.5 (tl/fade-in eq4)]
         [:t 6.5 (tl/create box)]
         [:t 8 (tl/wait 1)])]

    {:title title :eq-final eq3 :timeline timeline}))

(defn derivation-step-5-scene []
  "Step 5: Combine into the functional to minimize"
  (let [title (-> (mo/text "Step 5: The Functional" :font-size 36 :color (:step colors))
                  (mo/to-edge :up))

        recall1 (-> (typo/tex "v = \\sqrt{2gy}" :t2c t2c :font-size 28)
                    (mo/shift [-4 1.5 0]))
        recall2 (-> (typo/tex "ds = \\sqrt{1+y'^2}\\,dx" :t2c t2c :font-size 28)
                    (mo/shift [4 1.5 0]))

        eq1 (-> (typo/tex eq-dt :t2c t2c :font-size 36)
                (mo/shift [0 0.5 0]))

        eq2 (-> (typo/tex eq-dt-substituted :t2c t2c :font-size 36)
                (mo/shift [0 -0.3 0]))

        eq3 (-> (typo/tex eq-functional-clean :t2c t2c :font-size 42)
                (mo/shift [0 -1.5 0]))

        box (mo/surrounding-rectangle eq3 :color (:highlight colors) :buff 0.2)

        timeline
        (tl/timeline
         [:t 0 (tl/write title)]
         [:t 0.5 (tl/|| (tl/fade-in recall1) (tl/fade-in recall2))]
         [:t 2 (tl/write eq1)]
         [:t 3.5 (tl/transform-matching-tex eq1 eq2)]
         [:t 5 (tl/write eq3)]
         [:t 7 (tl/create box)]
         [:t 8.5 (tl/|| (tl/fade-out recall1) (tl/fade-out recall2))]
         [:t 9.5 (tl/wait 1)])]

    {:title title :functional eq3 :timeline timeline}))

(defn derivation-step-6-scene []
  "Step 6: Identify Lagrangian L(y, y')"
  (let [title (-> (mo/text "Step 6: The Lagrangian" :font-size 36 :color (:step colors))
                  (mo/to-edge :up))

        eq1 (-> (typo/tex eq-lagrangian-form :t2c t2c :font-size 36)
                (mo/shift [0 1 0]))

        eq2 (-> (typo/tex eq-lagrangian-def :t2c t2c :font-size 42)
                (mo/shift [0 -0.2 0]))

        note (-> (mo/text "Notice: L depends on y and y', but NOT explicitly on x"
                          :font-size 26 :color (:highlight colors))
                 (mo/shift [0 -1.5 0]))

        box (mo/surrounding-rectangle eq2 :color (:highlight colors) :buff 0.2)

        timeline
        (tl/timeline
         [:t 0 (tl/write title)]
         [:t 1 (tl/write eq1)]
         [:t 2.5 (tl/write eq2)]
         [:t 4 (tl/create box)]
         [:t 5.5 (tl/write note)]
         [:t 7 (tl/wait 1)])]

    {:title title :lagrangian eq2 :timeline timeline}))

(defn derivation-step-7-scene []
  "Step 7: Euler-Lagrange → Beltrami Identity"
  (let [title (-> (mo/text "Step 7: Beltrami Identity" :font-size 36 :color (:step colors))
                  (mo/to-edge :up))

        eq-el (-> (typo/tex eq-euler-lagrange :t2c t2c :font-size 32)
                  (mo/shift [0 1.5 0]))

        el-label (-> (mo/text "Euler-Lagrange equation" :font-size 24)
                     (mo/next-to eq-el :right :buff 0.3))

        condition (-> (typo/tex eq-beltrami-condition :t2c t2c :font-size 32)
                      (mo/shift [0 0.5 0]))

        note (-> (typo/tex eq-beltrami-note :font-size 24)
                 (mo/next-to condition :right :buff 0.3))

        eq-beltrami (-> (typo/tex eq-beltrami-identity :t2c t2c :font-size 48)
                        (mo/shift [0 -0.8 0]))

        beltrami-label (-> (typo/tex eq-beltrami-name :font-size 28 :color (:highlight colors))
                           (mo/next-to eq-beltrami :down :buff 0.3))

        box (mo/surrounding-rectangle eq-beltrami :color (:highlight colors) :buff 0.25)

        timeline
        (tl/timeline
         [:t 0 (tl/write title)]
         [:t 1 (tl/|| (tl/write eq-el) (tl/fade-in el-label))]
         [:t 3 (tl/|| (tl/write condition) (tl/fade-in note))]
         [:t 5 (tl/write eq-beltrami)]
         [:t 6.5 (tl/|| (tl/create box) (tl/write beltrami-label))]
         [:t 8.5 (tl/wait 1)])]

    {:title title :beltrami eq-beltrami :timeline timeline}))

(defn derivation-step-8-scene []
  "Step 8: Compute ∂L/∂y' and substitute"
  (let [title (-> (mo/text "Step 8: Apply Beltrami Identity" :font-size 36 :color (:step colors))
                  (mo/to-edge :up))

        recall-L (-> (typo/tex "L = \\sqrt{\\frac{1+y'^2}{y}}" :t2c t2c :font-size 28)
                     (mo/to-corner :ul :buff 0.5))

        eq1 (-> (typo/tex eq-partial-L-result :t2c t2c :font-size 32)
                (mo/shift [0 1.2 0]))

        eq2 (-> (typo/tex eq-beltrami-sub :t2c t2c :font-size 28)
                (mo/shift [0 0.3 0]))

        eq3 (-> (typo/tex eq-beltrami-simplify2 :t2c t2c :font-size 32)
                (mo/shift [0 -0.5 0]))

        eq4 (-> (typo/tex eq-beltrami-simplify3 :t2c t2c :font-size 36)
                (mo/shift [0 -1.5 0]))

        timeline
        (tl/timeline
         [:t 0 (tl/write title)]
         [:t 0.5 (tl/fade-in recall-L)]
         [:t 1.5 (tl/write eq1)]
         [:t 3.5 (tl/write eq2)]
         [:t 5.5 (tl/transform-matching-tex eq2 eq3)]
         [:t 7.5 (tl/transform-matching-tex eq3 eq4)]
         [:t 9 (tl/wait 1)])]

    {:title title :timeline timeline}))

(defn derivation-step-9-scene []
  "Step 9: Solve for the key relation y(1+y'²) = const"
  (let [title (-> (mo/text "Step 9: The Key Equation" :font-size 36 :color (:step colors))
                  (mo/to-edge :up))

        eq1 (-> (typo/tex eq-solution-step1 :t2c t2c :font-size 36)
                (mo/shift [0 1 0]))

        eq2 (-> (typo/tex eq-solution-step2 :t2c t2c :font-size 42)
                (mo/shift [0 0 0]))

        eq3 (-> (typo/tex eq-solution-final :t2c t2c :font-size 48)
                (mo/shift [0 -1.2 0]))

        eq4 (-> (typo/tex eq-constant-def :font-size 28)
                (mo/next-to eq3 :down :buff 0.3))

        box (mo/surrounding-rectangle eq3 :color (:highlight colors) :buff 0.25)

        timeline
        (tl/timeline
         [:t 0 (tl/write title)]
         [:t 1 (tl/write eq1)]
         [:t 2.5 (tl/transform-matching-tex eq1 eq2)]
         [:t 4 (tl/transform-matching-tex eq2 eq3)]
         [:t 5.5 (tl/|| (tl/create box) (tl/fade-in eq4))]
         [:t 7 (tl/wait 1)])]

    {:title title :key-equation eq3 :timeline timeline}))

(defn derivation-step-10-scene []
  "Step 10: Solve the ODE with substitution"
  (let [title (-> (mo/text "Step 10: Solve the Differential Equation" :font-size 36 :color (:step colors))
                  (mo/to-edge :up))

        eq1 (-> (typo/tex eq-ode-sqrt :t2c t2c :font-size 32)
                (mo/shift [0 1.5 0]))

        eq2 (-> (typo/tex eq-ode-separate :t2c t2c :font-size 32)
                (mo/shift [0 0.7 0]))

        sub-label (-> (mo/text "Use substitution:" :font-size 28)
                      (mo/shift [-4 -0.2 0]))

        eq3 (-> (typo/tex eq-sub-y :t2c t2c :font-size 32)
                (mo/shift [0 -0.2 0]))

        eq4 (-> (typo/tex eq-sub-dy :t2c t2c :font-size 32)
                (mo/shift [0 -0.9 0]))

        eq5 (-> (typo/tex eq-sub-2A-y :t2c t2c :font-size 28)
                (mo/shift [0 -1.6 0]))

        timeline
        (tl/timeline
         [:t 0 (tl/write title)]
         [:t 1 (tl/write eq1)]
         [:t 2.5 (tl/write eq2)]
         [:t 4 (tl/fade-in sub-label)]
         [:t 5 (tl/write eq3)]
         [:t 6.5 (tl/write eq4)]
         [:t 8 (tl/write eq5)]
         [:t 9.5 (tl/wait 1)])]

    {:title title :timeline timeline}))

(defn derivation-step-11-scene []
  "Step 11: Integrate to get x(φ)"
  (let [title (-> (mo/text "Step 11: Integration" :font-size 36 :color (:step colors))
                  (mo/to-edge :up))

        eq1 (-> (typo/tex eq-trig-identity :font-size 28)
                (mo/shift [0 1.5 0]))

        eq2 (-> (typo/tex eq-integral-final :t2c t2c :font-size 36)
                (mo/shift [0 0.5 0]))

        eq3 (-> (typo/tex eq-integrate-x :t2c t2c :font-size 42)
                (mo/shift [0 -0.7 0]))

        note (-> (mo/text "(setting x₀ = 0 for simplicity)" :font-size 24)
                 (mo/next-to eq3 :down :buff 0.3))

        timeline
        (tl/timeline
         [:t 0 (tl/write title)]
         [:t 1 (tl/write eq1)]
         [:t 3 (tl/write eq2)]
         [:t 5 (tl/write eq3)]
         [:t 6.5 (tl/fade-in note)]
         [:t 8 (tl/wait 1)])]

    {:title title :timeline timeline}))

(defn derivation-step-12-scene []
  "Step 12: Final Result - The Cycloid!"
  (let [title (-> (mo/text "Step 12: The Solution" :font-size 36 :color (:step colors))
                  (mo/to-edge :up))

        result-label (-> (mo/text "The curve that minimizes descent time:" :font-size 28)
                         (mo/shift [0 1.5 0]))

        eq-x (-> (typo/tex eq-cycloid-x :t2c t2c :font-size 48)
                 (mo/shift [0 0.5 0]))

        eq-y (-> (typo/tex eq-cycloid-y :t2c t2c :font-size 48)
                 (mo/shift [0 -0.5 0]))

        result-name (-> (typo/tex eq-cycloid-name :font-size 56 :color (:cycloid colors))
                        (mo/shift [0 -1.8 0]))

        box (mo/surrounding-rectangle
             (mo/vgroup [eq-x eq-y])
             :color (:cycloid colors) :buff 0.3 :stroke-width 4)

        timeline
        (tl/timeline
         [:t 0 (tl/write title)]
         [:t 1 (tl/fade-in result-label)]
         [:t 2.5 (tl/write eq-x)]
         [:t 4 (tl/write eq-y)]
         [:t 5.5 (tl/create box)]
         [:t 7 (tl/write result-name)]
         [:t 9 (tl/wait 2)])]

    {:title title :equations [eq-x eq-y] :timeline timeline}))

;; =============================================================================
;; Scene: What is a Cycloid?
;; =============================================================================

(defn cycloid-explanation-scene []
  "Explain what a cycloid is geometrically"
  (let [title (-> (mo/text "What is a Cycloid?" :font-size 40)
                  (mo/to-edge :up))

        explanation (-> (mo/text "The path traced by a point on a rolling circle"
                                 :font-size 28)
                        (mo/shift [0 1.5 0]))

        ;; Rolling circle visualization would go here
        ;; For now, just show the equations with geometric meaning

        eq1 (-> (typo/tex "x = r(\\theta - \\sin\\theta)" :t2c t2c :font-size 36)
                (mo/shift [-2.5 0 0]))
        eq2 (-> (typo/tex "y = r(1 - \\cos\\theta)" :t2c t2c :font-size 36)
                (mo/shift [2.5 0 0]))

        note1 (-> (mo/text "horizontal: angle minus sine" :font-size 22)
                  (mo/next-to eq1 :down))
        note2 (-> (mo/text "vertical: one minus cosine" :font-size 22)
                  (mo/next-to eq2 :down))

        r-note (-> (typo/tex "r = \\text{radius of rolling circle}" :font-size 28)
                   (mo/shift [0 -2 0]))

        timeline
        (tl/timeline
         [:t 0 (tl/write title)]
         [:t 1 (tl/fade-in explanation)]
         [:t 2.5 (tl/|| (tl/write eq1) (tl/write eq2))]
         [:t 4 (tl/|| (tl/fade-in note1) (tl/fade-in note2))]
         [:t 5.5 (tl/fade-in r-note)]
         [:t 7 (tl/wait 1)])]

    {:title title :timeline timeline}))

;; =============================================================================
;; Scene: Race Animation (After Derivation)
;; =============================================================================

(defn race-scene [curves]
  "Animate balls racing down all three curves"
  (let [physics (compare-paths -4 2 4 -2)

        ball-straight (mo/dot [0 0 0] :color (:straight colors) :radius 0.12)
        ball-parabola (mo/dot [0 0 0] :color (:parabola colors) :radius 0.12)
        ball-cycloid (mo/dot [0 0 0] :color (:cycloid colors) :radius 0.12)

        time-straight (get-in physics [:straight :time])
        time-parabola (get-in physics [:parabola :time])
        time-cycloid (get-in physics [:cycloid :time])

        ;; Scale for visibility
        scale 1.8
        anim-straight (* scale time-straight)
        anim-parabola (* scale time-parabola)
        anim-cycloid (* scale time-cycloid)

        title (-> (mo/text "The Race!" :font-size 40)
                  (mo/to-edge :up))

        ;; Results
        results (mo/vgroup
                 [(mo/text (format "Straight: %.3fs" time-straight)
                           :font-size 28 :color (:straight colors))
                  (mo/text (format "Parabola: %.3fs" time-parabola)
                           :font-size 28 :color (:parabola colors))
                  (mo/text (format "Cycloid:  %.3fs ← FASTEST!" time-cycloid)
                           :font-size 28 :color (:cycloid colors))])
        _ (-> results
              (mo/arrange :down :buff 0.3 :aligned-edge :left)
              (mo/to-corner :ur :buff 0.5))

        timeline
        (tl/timeline
         [:t 0 (tl/write title)]

         ;; Position balls at start
         [:t 0.5 (tl/|| (tl/add ball-straight)
                        (tl/add ball-parabola)
                        (tl/add ball-cycloid))]
         [:t 0.6 (tl/|| (mo/move-to ball-straight (mo/get-start (:straight curves)))
                        (mo/move-to ball-parabola (mo/get-start (:parabola curves)))
                        (mo/move-to ball-cycloid (mo/get-start (:cycloid curves))))]

         ;; Race!
         [:t 1.5 (tl/|| (mo/move-along-path ball-straight (:straight curves)
                                            :run-time anim-straight :rate-func tl/linear)
                        (mo/move-along-path ball-parabola (:parabola curves)
                                            :run-time anim-parabola :rate-func tl/linear)
                        (mo/move-along-path ball-cycloid (:cycloid curves)
                                            :run-time anim-cycloid :rate-func tl/linear))]

         ;; Show results after race
         [:t (+ 1.5 (max anim-straight anim-parabola anim-cycloid) 0.5)
          (tl/write results)]

         [:cursor (tl/wait 3)])]

    {:title title :results results :timeline timeline}))

;; =============================================================================
;; Scene: Tautochrone Property (Bonus)
;; =============================================================================

(defn tautochrone-scene []
  "The cycloid's remarkable tautochrone property"
  (let [title (-> (mo/text "Bonus: The Tautochrone Property" :font-size 36)
                  (mo/to-edge :up))

        fact (-> (mo/text "Same curve, different name, amazing property:"
                          :font-size 28)
                 (mo/shift [0 1.2 0]))

        property (-> (typo/tex "\\text{All starting points reach the bottom in } \\textbf{equal time!}"
                               :font-size 32 :color (:cycloid colors))
                     (mo/shift [0 0 0]))

        explanation (mo/vgroup
                     [(mo/text "• Balls released from ANY height on the cycloid" :font-size 24)
                      (mo/text "• All arrive at the lowest point simultaneously" :font-size 24)
                      (mo/text "• Used in Huygens' pendulum clocks (1673)" :font-size 24)])
        _ (-> explanation
              (mo/arrange :down :buff 0.3 :aligned-edge :left)
              (mo/shift [0 -1.5 0]))

        timeline
        (tl/timeline
         [:t 0 (tl/write title)]
         [:t 1 (tl/fade-in fact)]
         [:t 2.5 (tl/write property)]
         [:t 4.5 (tl/write explanation)]
         [:t 7 (tl/wait 2)])]

    {:title title :timeline timeline}))

;; =============================================================================
;; Full Video Composition
;; =============================================================================

(defn brachistochrone-full-derivation []
  "Complete brachistochrone video with full derivation then animation"
  (let [intro (intro-scene)
        step1 (derivation-step-1-scene)
        step2 (derivation-step-2-scene)
        step3 (derivation-step-3-scene)
        step4 (derivation-step-4-scene)
        step5 (derivation-step-5-scene)
        step6 (derivation-step-6-scene)
        step7 (derivation-step-7-scene)
        step8 (derivation-step-8-scene)
        step9 (derivation-step-9-scene)
        step10 (derivation-step-10-scene)
        step11 (derivation-step-11-scene)
        step12 (derivation-step-12-scene)
        cycloid-explain (cycloid-explanation-scene)
        race (race-scene (:curves intro))
        tautochrone (tautochrone-scene)

        full-timeline
        (tl/timeline
         ;; Introduction (0-13s)
         [:t 0 (:timeline intro)]

         ;; Derivation steps (13s onwards)
         [:t 14 (:timeline step1)] ; Problem setup
         [:t 20 (:timeline step2)] ; dt = ds/v
         [:t 27 (:timeline step3)] ; Energy conservation
         [:t 38 (:timeline step4)] ; Arc length
         [:t 48 (:timeline step5)] ; Combine functional
         [:t 60 (:timeline step6)] ; Identify Lagrangian
         [:t 70 (:timeline step7)] ; Beltrami identity
         [:t 82 (:timeline step8)] ; Apply Beltrami
         [:t 94 (:timeline step9)] ; Key equation
         [:t 104 (:timeline step10)] ; Solve ODE
         [:t 116 (:timeline step11)] ; Integration
         [:t 127 (:timeline step12)] ; Final cycloid!

         ;; Cycloid explanation
         [:t 140 (:timeline cycloid-explain)]

         ;; Now show the race!
         [:t 150 (:timeline race)]

         ;; Tautochrone bonus
         [:t 170 (:timeline tautochrone)])]

    {:intro intro
     :steps [step1 step2 step3 step4 step5 step6
             step7 step8 step9 step10 step11 step12]
     :race race
     :timeline full-timeline}))

;; =============================================================================
;; Rendering Functions
;; =============================================================================

(defn render-full-derivation
  "Render the complete brachistochrone derivation video in pure Clojure."
  []
  (manim/init!)
  (println "\n=== Brachistochrone Full Derivation ===")
  (println "Rendering complete video with all 12 derivation steps...")

  (let [construct-fn
        (fn [self]
          ;; === INTRO ===
          (let [title (-> (create-text "The Brachistochrone Problem" :font-size 48)
                          (to-edge :up))]
            (play! self (anim-write title))
            (wait! self 1))

          (let [subtitle (-> (create-tex "\\beta\\rho\\alpha\\chi\\iota\\sigma\\tau o\\varsigma \\; \\chi\\rho o\\nu o\\varsigma = \\text{shortest time}" :font-size 32)
                             (shift [0 2 0]))]
            (play! self (anim-fade-in subtitle))
            (wait! self 2)
            (play! self (anim-fade-out subtitle)))

          ;; Show points A and B
          (let [pt-a (create-dot [-4 2 0] :color :green :radius 0.12)
                pt-b (create-dot [4 -2 0] :color :red :radius 0.12)
                label-a (-> (create-tex "A" :color :green) (next-to pt-a :up))
                label-b (-> (create-tex "B" :color :red) (next-to pt-b :down))]
            (play! self (anim-create pt-a) (anim-create pt-b))
            (play! self (anim-write label-a) (anim-write label-b))
            (wait! self 1)

            ;; Draw curves
            (let [straight (create-line [-4 2 0] [4 -2 0] :color :blue)
                  parabola (create-parametric-curve
                            (fn [t] [(+ -4 (* t 8)) (+ 2 (* t -4) (* -2 t (- 1 t)))])
                            [0 1] :color :yellow)
                  cycloid (create-parametric-curve
                           (fn [theta]
                             (let [r 1.6
                                   x (+ -4 (* r (- theta (Math/sin theta))))
                                   y (- 2 (* r (- 1 (Math/cos theta))))]
                               [x y]))
                           [0 2.5] :color :green)]
              (play! self (anim-create straight))
              (wait! self 0.5)
              (play! self (anim-create parabola))
              (wait! self 0.5)
              (play! self (anim-create cycloid))
              (wait! self 1)

              ;; Clear for derivation
              (play! self (anim-fade-out straight) (anim-fade-out parabola)
                     (anim-fade-out cycloid) (anim-fade-out pt-a) (anim-fade-out pt-b)
                     (anim-fade-out label-a) (anim-fade-out label-b))))

          ;; === STEP 1: Problem Setup ===
          (let [step1-title (-> (create-text "Step 1: The Minimization Problem" :font-size 36 :color :yellow)
                                (to-edge :up))
                eq1 (-> (create-tex eq-problem :font-size 42)
                        (shift [0 1 0]))]
            (play! self (anim-write step1-title))
            (play! self (anim-write eq1))
            (wait! self 2)
            (play! self (anim-fade-out step1-title) (anim-fade-out eq1)))

          ;; === STEP 2: Time Element ===
          (let [step2-title (-> (create-text "Step 2: Time Element" :font-size 36 :color :yellow)
                                (to-edge :up))
                eq1 (-> (create-tex eq-dt :font-size 42)
                        (shift [0 1 0]))
                eq2 (-> (create-tex eq-dt-explanation :font-size 28)
                        (shift [0 0 0]))]
            (play! self (anim-write step2-title))
            (play! self (anim-write eq1))
            (wait! self 1)
            (play! self (anim-fade-in eq2))
            (wait! self 2)
            (play! self (anim-fade-out step2-title) (anim-fade-out eq1) (anim-fade-out eq2)))

          ;; === STEP 3: Energy Conservation ===
          (let [step3-title (-> (create-text "Step 3: Energy Conservation" :font-size 36 :color :yellow)
                                (to-edge :up))
                eq1 (-> (create-tex eq-energy-start :font-size 36)
                        (shift [0 1.5 0]))
                eq2 (-> (create-tex eq-energy-cancel :font-size 36)
                        (shift [0 0.5 0]))
                eq3 (-> (create-tex eq-velocity :font-size 48)
                        (shift [0 -0.8 0]))
                box (create-rectangle eq3 :color :teal :buff 0.2)]
            (play! self (anim-write step3-title))
            (play! self (anim-write eq1))
            (wait! self 1)
            (play! self (anim-write eq2))
            (wait! self 1)
            (play! self (anim-write eq3))
            (wait! self 1)
            (play! self (anim-create box))
            (wait! self 2)
            (play! self (anim-fade-out step3-title) (anim-fade-out eq1)
                   (anim-fade-out eq2) (anim-fade-out eq3) (anim-fade-out box)))

          ;; === STEP 4: Arc Length ===
          (let [step4-title (-> (create-text "Step 4: Arc Length Element" :font-size 36 :color :yellow)
                                (to-edge :up))
                eq1 (-> (create-tex eq-arc-diff :font-size 36)
                        (shift [0 1.2 0]))
                eq2 (-> (create-tex eq-arc-final :font-size 48)
                        (shift [0 -0.2 0]))
                box (create-rectangle eq2 :color :teal :buff 0.2)]
            (play! self (anim-write step4-title))
            (play! self (anim-write eq1))
            (wait! self 1.5)
            (play! self (anim-write eq2))
            (wait! self 1)
            (play! self (anim-create box))
            (wait! self 2)
            (play! self (anim-fade-out step4-title) (anim-fade-out eq1)
                   (anim-fade-out eq2) (anim-fade-out box)))

          ;; === STEP 5: The Functional ===
          (let [step5-title (-> (create-text "Step 5: The Functional" :font-size 36 :color :yellow)
                                (to-edge :up))
                recall1 (-> (create-tex "v = \\sqrt{2gy}" :font-size 28)
                            (shift [-4 1.5 0]))
                recall2 (-> (create-tex "ds = \\sqrt{1+y'^2}\\,dx" :font-size 28)
                            (shift [4 1.5 0]))
                eq1 (-> (create-tex eq-functional-clean :font-size 42)
                        (shift [0 -0.5 0]))
                box (create-rectangle eq1 :color :teal :buff 0.2)]
            (play! self (anim-write step5-title))
            (play! self (anim-fade-in recall1) (anim-fade-in recall2))
            (wait! self 1)
            (play! self (anim-write eq1))
            (wait! self 1)
            (play! self (anim-create box))
            (wait! self 2)
            (play! self (anim-fade-out step5-title) (anim-fade-out recall1)
                   (anim-fade-out recall2) (anim-fade-out eq1) (anim-fade-out box)))

          ;; === STEP 6: Identify Lagrangian ===
          (let [step6-title (-> (create-text "Step 6: The Lagrangian" :font-size 36 :color :yellow)
                                (to-edge :up))
                eq1 (-> (create-tex eq-lagrangian-form :font-size 36)
                        (shift [0 1 0]))
                eq2 (-> (create-tex eq-lagrangian-def :font-size 42)
                        (shift [0 -0.2 0]))
                note (-> (create-text "Notice: L depends on y and y', but NOT on x" :font-size 26 :color :teal)
                         (shift [0 -1.5 0]))
                box (create-rectangle eq2 :color :teal :buff 0.2)]
            (play! self (anim-write step6-title))
            (play! self (anim-write eq1))
            (wait! self 1)
            (play! self (anim-write eq2))
            (wait! self 1)
            (play! self (anim-create box))
            (wait! self 1)
            (play! self (anim-write note))
            (wait! self 2)
            (play! self (anim-fade-out step6-title) (anim-fade-out eq1)
                   (anim-fade-out eq2) (anim-fade-out note) (anim-fade-out box)))

          ;; === STEP 7: Beltrami Identity (KEY!) ===
          (let [step7-title (-> (create-text "Step 7: Beltrami Identity" :font-size 36 :color :yellow)
                                (to-edge :up))
                eq-el (-> (create-tex eq-euler-lagrange :font-size 32)
                          (shift [0 1.5 0]))
                condition (-> (create-tex eq-beltrami-condition :font-size 32)
                              (shift [0 0.5 0]))
                eq-beltrami (-> (create-tex eq-beltrami-identity :font-size 48)
                                (shift [0 -0.8 0]))
                beltrami-label (-> (create-tex eq-beltrami-name :font-size 28 :color :teal)
                                   (shift [0 -1.8 0]))
                box (create-rectangle eq-beltrami :color :teal :buff 0.25)]
            (play! self (anim-write step7-title))
            (play! self (anim-write eq-el))
            (wait! self 1.5)
            (play! self (anim-write condition))
            (wait! self 1.5)
            (play! self (anim-write eq-beltrami))
            (wait! self 1)
            (play! self (anim-create box) (anim-write beltrami-label))
            (wait! self 3)
            (play! self (anim-fade-out step7-title) (anim-fade-out eq-el)
                   (anim-fade-out condition) (anim-fade-out eq-beltrami)
                   (anim-fade-out beltrami-label) (anim-fade-out box)))

          ;; === STEP 8: Apply Beltrami ===
          (let [step8-title (-> (create-text "Step 8: Apply Beltrami Identity" :font-size 36 :color :yellow)
                                (to-edge :up))
                recall-L (-> (create-tex "L = \\sqrt{\\frac{1+y'^2}{y}}" :font-size 28)
                             (to-corner :ul :buff 0.5))
                eq1 (-> (create-tex eq-partial-L-result :font-size 32)
                        (shift [0 1 0]))
                eq2 (-> (create-tex eq-beltrami-simplify3 :font-size 36)
                        (shift [0 -0.5 0]))]
            (play! self (anim-write step8-title))
            (play! self (anim-fade-in recall-L))
            (wait! self 1)
            (play! self (anim-write eq1))
            (wait! self 2)
            (play! self (anim-write eq2))
            (wait! self 2)
            (play! self (anim-fade-out step8-title) (anim-fade-out recall-L)
                   (anim-fade-out eq1) (anim-fade-out eq2)))

          ;; === STEP 9: Key Equation ===
          (let [step9-title (-> (create-text "Step 9: The Key Equation" :font-size 36 :color :yellow)
                                (to-edge :up))
                eq1 (-> (create-tex eq-solution-step1 :font-size 36)
                        (shift [0 1 0]))
                eq2 (-> (create-tex eq-solution-final :font-size 48)
                        (shift [0 -0.5 0]))
                eq3 (-> (create-tex eq-constant-def :font-size 28)
                        (shift [0 -1.5 0]))
                box (create-rectangle eq2 :color :teal :buff 0.25)]
            (play! self (anim-write step9-title))
            (play! self (anim-write eq1))
            (wait! self 1.5)
            (play! self (anim-write eq2))
            (wait! self 1)
            (play! self (anim-create box) (anim-fade-in eq3))
            (wait! self 2)
            (play! self (anim-fade-out step9-title) (anim-fade-out eq1)
                   (anim-fade-out eq2) (anim-fade-out eq3) (anim-fade-out box)))

          ;; === STEP 10: Solve the ODE ===
          (let [step10-title (-> (create-text "Step 10: Solve the Differential Equation" :font-size 36 :color :yellow)
                                 (to-edge :up))
                eq1 (-> (create-tex eq-ode-sqrt :font-size 32)
                        (shift [0 1.2 0]))
                eq2 (-> (create-tex eq-ode-separate :font-size 32)
                        (shift [0 0.3 0]))
                sub-label (-> (create-text "Substitution:" :font-size 28)
                              (shift [-4 -0.6 0]))
                eq3 (-> (create-tex eq-sub-y :font-size 32)
                        (shift [0 -0.6 0]))]
            (play! self (anim-write step10-title))
            (play! self (anim-write eq1))
            (wait! self 1.5)
            (play! self (anim-write eq2))
            (wait! self 1.5)
            (play! self (anim-fade-in sub-label))
            (play! self (anim-write eq3))
            (wait! self 2)
            (play! self (anim-fade-out step10-title) (anim-fade-out eq1)
                   (anim-fade-out eq2) (anim-fade-out sub-label) (anim-fade-out eq3)))

          ;; === STEP 11: Integration ===
          (let [step11-title (-> (create-text "Step 11: Integration" :font-size 36 :color :yellow)
                                 (to-edge :up))
                eq1 (-> (create-tex eq-trig-identity :font-size 28)
                        (shift [0 1.2 0]))
                eq2 (-> (create-tex eq-integral-final :font-size 36)
                        (shift [0 0.2 0]))
                eq3 (-> (create-tex eq-integrate-x :font-size 42)
                        (shift [0 -1 0]))]
            (play! self (anim-write step11-title))
            (play! self (anim-write eq1))
            (wait! self 1.5)
            (play! self (anim-write eq2))
            (wait! self 1.5)
            (play! self (anim-write eq3))
            (wait! self 2)
            (play! self (anim-fade-out step11-title) (anim-fade-out eq1)
                   (anim-fade-out eq2) (anim-fade-out eq3)))

          ;; === STEP 12: THE CYCLOID! ===
          (let [step12-title (-> (create-text "Step 12: The Solution" :font-size 36 :color :yellow)
                                 (to-edge :up))
                result-label (-> (create-text "The curve that minimizes descent time:" :font-size 28)
                                 (shift [0 1.5 0]))
                eq-x (-> (create-tex eq-cycloid-x :font-size 48)
                         (shift [0 0.5 0]))
                eq-y (-> (create-tex eq-cycloid-y :font-size 48)
                         (shift [0 -0.5 0]))
                result-name (-> (create-tex eq-cycloid-name :font-size 56 :color :green)
                                (shift [0 -1.8 0]))
                box (create-rectangle (create-vgroup eq-x eq-y) :color :green :buff 0.3)]
            (play! self (anim-write step12-title))
            (play! self (anim-fade-in result-label))
            (wait! self 1)
            (play! self (anim-write eq-x))
            (wait! self 1)
            (play! self (anim-write eq-y))
            (wait! self 1)
            (play! self (anim-create box))
            (wait! self 1)
            (play! self (anim-write result-name))
            (wait! self 3)
            (play! self (anim-fade-out step12-title) (anim-fade-out result-label)
                   (anim-fade-out eq-x) (anim-fade-out eq-y)
                   (anim-fade-out result-name) (anim-fade-out box)))

          ;; === RACE ANIMATION ===
          (let [race-title (-> (create-text "The Race!" :font-size 40)
                               (to-edge :up))
                ;; Recreate curves for race
                pt-a (create-dot [-4 2 0] :color :green :radius 0.12)
                pt-b (create-dot [4 -2 0] :color :red :radius 0.12)
                straight (create-line [-4 2 0] [4 -2 0] :color :blue)
                cycloid (create-parametric-curve
                         (fn [theta]
                           (let [r 1.6
                                 x (+ -4 (* r (- theta (Math/sin theta))))
                                 y (- 2 (* r (- 1 (Math/cos theta))))]
                             [x y]))
                         [0 2.5] :color :green)

                ;; Physics results
                physics (compare-paths -4 2 4 -2)
                time-straight (get-in physics [:straight :time])
                time-cycloid (get-in physics [:cycloid :time])

                results (-> (create-vgroup
                             (create-text (format "Straight: %.3fs" time-straight) :font-size 28 :color :blue)
                             (create-text (format "Cycloid: %.3fs (FASTEST!)" time-cycloid) :font-size 28 :color :green))
                            (arrange :down :buff 0.3)
                            (to-corner :ur :buff 0.5))]

            (play! self (anim-write race-title))
            (play! self (anim-create pt-a) (anim-create pt-b))
            (play! self (anim-create straight) (anim-create cycloid))
            (wait! self 2)
            (play! self (anim-write results))
            (wait! self 3)
            (play! self (anim-fade-out race-title) (anim-fade-out pt-a) (anim-fade-out pt-b)
                   (anim-fade-out straight) (anim-fade-out cycloid) (anim-fade-out results)))

          ;; === FINAL MESSAGE ===
          (let [final-msg (-> (create-text "The Cycloid is the Brachistochrone!" :font-size 42 :color :green)
                              (shift [0 0 0]))]
            (play! self (anim-write final-msg))
            (wait! self 3)))

        ;; Create and render scene
        scene-class (manim/create-scene-class "BrachistochroneDerivation" construct-fn)
        scene (scene-class)]

    (println "Rendering video...")
    (manim/render-scene! scene {:quality "high_quality"})
    (println "\n=== Done! Check media/videos/ for the output ===")))

(defn render-intro
  "Render just the introduction scene."
  []
  (manim/init!)
  (println "\n=== Brachistochrone Intro ===")

  (let [construct-fn
        (fn [self]
          ;; Title
          (let [title (-> (create-text "The Brachistochrone Problem" :font-size 48)
                          (to-edge :up))]
            (play! self (anim-write title))
            (wait! self 1))

          ;; Subtitle
          (let [subtitle (-> (create-tex "\\beta\\rho\\alpha\\chi\\iota\\sigma\\tau o\\varsigma \\; \\chi\\rho o\\nu o\\varsigma = \\text{shortest time}" :font-size 32)
                             (shift [0 2 0]))]
            (play! self (anim-fade-in subtitle))
            (wait! self 2)
            (play! self (anim-fade-out subtitle)))

          ;; Show points A and B
          (let [pt-a (create-dot [-4 2 0] :color :green :radius 0.12)
                pt-b (create-dot [4 -2 0] :color :red :radius 0.12)
                label-a (-> (create-tex "A" :color :green) (next-to pt-a :up))
                label-b (-> (create-tex "B" :color :red) (next-to pt-b :down))]
            (play! self (anim-create pt-a) (anim-create pt-b))
            (play! self (anim-write label-a) (anim-write label-b))
            (wait! self 1)

            ;; Draw curves
            (let [straight (create-line [-4 2 0] [4 -2 0] :color :blue)
                  parabola (create-parametric-curve
                            (fn [t] [(+ -4 (* t 8)) (+ 2 (* t -4) (* -2 t (- 1 t)))])
                            [0 1] :color :yellow)
                  cycloid (create-parametric-curve
                           (fn [theta]
                             (let [r 1.6
                                   x (+ -4 (* r (- theta (Math/sin theta))))
                                   y (- 2 (* r (- 1 (Math/cos theta))))]
                               [x y]))
                           [0 2.5] :color :green)]
              (play! self (anim-create straight))
              (wait! self 0.5)
              (play! self (anim-create parabola))
              (wait! self 0.5)
              (play! self (anim-create cycloid))
              (wait! self 2))))

        scene-class (manim/create-scene-class "BrachistochroneIntro" construct-fn)
        scene (scene-class)]

    (manim/render-scene! scene {:quality "medium_quality"})
    (println "Done!")))

(defn render-step
  "Render a specific derivation step (1-12) in pure Clojure."
  [n]
  (manim/init!)
  (println (str "\n=== Rendering Step " n " ==="))

  (let [step-configs
        {1 {:title "Step 1: The Minimization Problem"
            :equations [[eq-problem 42 [0 1 0]]]}

         2 {:title "Step 2: Time Element"
            :equations [[eq-dt 42 [0 1 0]]
                        [eq-dt-explanation 28 [0 0 0]]]}

         3 {:title "Step 3: Energy Conservation"
            :equations [[eq-energy-start 36 [0 1.5 0]]
                        [eq-energy-cancel 36 [0 0.5 0]]
                        [eq-velocity 48 [0 -0.8 0]]]
            :highlight-last true}

         4 {:title "Step 4: Arc Length Element"
            :equations [[eq-arc-diff 36 [0 1.2 0]]
                        [eq-arc-final 48 [0 -0.2 0]]]
            :highlight-last true}

         5 {:title "Step 5: The Functional"
            :equations [[eq-functional-clean 42 [0 0 0]]]
            :highlight-last true}

         6 {:title "Step 6: The Lagrangian"
            :equations [[eq-lagrangian-form 36 [0 1 0]]
                        [eq-lagrangian-def 42 [0 -0.2 0]]]
            :highlight-last true}

         7 {:title "Step 7: Beltrami Identity"
            :equations [[eq-euler-lagrange 32 [0 1.5 0]]
                        [eq-beltrami-condition 32 [0 0.5 0]]
                        [eq-beltrami-identity 48 [0 -0.8 0]]]
            :highlight-last true}

         8 {:title "Step 8: Apply Beltrami Identity"
            :equations [[eq-partial-L-result 32 [0 1 0]]
                        [eq-beltrami-simplify3 36 [0 -0.5 0]]]}

         9 {:title "Step 9: The Key Equation"
            :equations [[eq-solution-step1 36 [0 1 0]]
                        [eq-solution-final 48 [0 -0.5 0]]]
            :highlight-last true}

         10 {:title "Step 10: Solve the ODE"
             :equations [[eq-ode-sqrt 32 [0 1.2 0]]
                         [eq-ode-separate 32 [0 0.3 0]]
                         [eq-sub-y 32 [0 -0.6 0]]]}

         11 {:title "Step 11: Integration"
             :equations [[eq-trig-identity 28 [0 1.2 0]]
                         [eq-integral-final 36 [0 0.2 0]]
                         [eq-integrate-x 42 [0 -1 0]]]}

         12 {:title "Step 12: The Solution - THE CYCLOID!"
             :equations [[eq-cycloid-x 48 [0 0.5 0]]
                         [eq-cycloid-y 48 [0 -0.5 0]]
                         [eq-cycloid-name 56 [0 -1.8 0]]]
             :highlight-last true
             :final-color :green}}

        config (get step-configs n)]

    (when config
      (let [construct-fn
            (fn [self]
              ;; Title
              (let [title (-> (create-text (:title config) :font-size 36 :color :yellow)
                              (to-edge :up))]
                (play! self (anim-write title))
                (wait! self 0.5))

              ;; Show equations sequentially
              (let [eq-mobjects
                    (doall
                     (for [[latex font-size pos] (:equations config)]
                       (let [color (when (and (:final-color config)
                                              (= latex (first (last (:equations config)))))
                                     (:final-color config))
                             eq (-> (create-tex latex :font-size font-size :color color)
                                    (shift pos))]
                         (play! self (anim-write eq))
                         (wait! self 1.5)
                         eq)))]

                ;; Highlight last equation if specified
                (when (:highlight-last config)
                  (let [last-eq (last eq-mobjects)
                        box (create-rectangle last-eq :color :teal :buff 0.2)]
                    (play! self (anim-create box))))

                (wait! self 2)))

            scene-class (manim/create-scene-class (str "Step" n) construct-fn)
            scene (scene-class)]

        (manim/render-scene! scene {:quality "medium_quality"})
        (println "Done!")))))

;; =============================================================================
;; REPL Examples
;; =============================================================================

(comment
  ;; Compute physics results
  (compare-paths -4 2 4 -2)

  ;; Render individual steps
  (render-step 1) ; Problem setup
  (render-step 3) ; Energy conservation v = √(2gy)
  (render-step 7) ; Beltrami identity
  (render-step 12) ; Final cycloid solution

  ;; Render full derivation (about 3 minutes)
  (render-full-derivation)

  ;; Just the intro
  (render-intro))
